#include "./types.h"
#include "./global.h"
#include "enums.h"
#include <format>

ValueRef value_make_int(int v, Span s) {
  ValueRef val = mk_shr(Value, s, VALUE_INT, v);
  return val;
}

ValueRef value_make_string(std::string s, Span sp) {
  ValueRef val = mk_shr(Value, sp, VALUE_STRING, imp_arena_strdup(arena, s.data()));
  return val;
}

ValueRef value_make_variable(std::string name, ValueRef value, bool const_,  Span sp) {
  ValueRef val = mk_shr(Value, sp, VALUE_VARIABLE, VariableValue(name, const_, value));
  return val;
}

ValueRef value_make_bool(bool v, Span s) {
    ValueRef val = mk_shr(Value, s, VALUE_BOOL, v);
    return val;
}


// Regular Nil are generated by non-source routines
ValueRef value_make_nil() {
  static ValueRef null_value = NULL;
  if (!null_value) {
    null_value = mk_shr(Value, make_span(0, 0, 0), VALUE_RNIL, NilValue(0));
  }
  return null_value;
}

// RNULL is strictly Runtime Generate Nil via the 'nil' keyword
ValueRef value_make_rnil(Span s) {
  static ValueRef rnull_value = NULL;
  if (!rnull_value) {
    rnull_value = mk_shr(Value, make_span(0, 0, 0), VALUE_NIL, NilValue(0));
  }
  return rnull_value;    
}

ValueRef value_make_native_fn(std::string name, int argc,
                            ValueRef (*fn)(Env *env, ValueList *args)) {
  ValueRef val = mk_shr(Value, make_span(0, 0, 0), VALUE_NATIVEFN, NativeFn_(name, argc, fn));
  return val;
}

ValueRef value_make_module(std::string mod_name, Module *mod) {
  ValueRef val = mk_shr(Value, make_span(0, 0, 0), VALUE_MODULE, ModuleValue(mod_name, mod));
  return val;
}

ValueRef value_make_error(std::string msg, Span error_span) {
  ValueRef val = mk_shr(Value, error_span, VALUE_ERROR,ErrorValue(error_span, msg));
  return val;
}

ValueRef value_add(ValueRef v1, ValueRef v2) {
    if (v1->kind == VALUE_INT && v2->kind == VALUE_INT) {
	auto i1 = std::get<int>(v1->data);
	auto i2 = std::get<int>(v2->data);
    return value_make_int(i1 + i2,
                          merge_span(v1->span, v2->span));
  }
  // TODO: replace with error value after integrating span in value struct
  return value_make_nil();
}

bool value_istruthy(ValueRef v) {
    if (v->kind == VALUE_INT) {
	auto int_value = std::get<int>(v->data);
	if (int_value > 0) {
	    return true;
	}
    } if (v->kind == VALUE_BOOL) {
	auto boolean_value = std::get<bool>(v->data);
	return boolean_value;
    } if (v->kind == VALUE_STRING) {
	auto string_value = as(std::string, v);
	return string_value.size() > 0;
    } if (v->kind == VALUE_NIL) {
	return false;
    } if (v->kind == VALUE_RNIL) {
	return false;
    }
    return false;
}

ValueRef value_eq(ValueRef v1, ValueRef v2) {
    if (v1->kind == VALUE_VARIABLE) {
	auto v = as(VariableValue, v1).value;
	return value_eq(v, v2);
    }
    
    if (v2->kind == VALUE_VARIABLE) {
	auto v = as(VariableValue, v2).value;
	return value_eq(v1, v);
    }
    
    if (v1->kind != v2->kind) return value_make_error("Type Mismatch", merge_span(v1->span, v2->span));
    if (v1->kind == VALUE_INT && v2->kind == VALUE_INT) {
	return value_make_bool((as(int, v1) == as(int, v2)), merge_span(v1->span, v2->span));
    }
    if (v1->kind == VALUE_STRING && v2->kind == VALUE_STRING) {
	auto s1 = as(std::string, v1);
	auto s2 = as(std::string, v2);
	return value_make_bool(s1 == s2, merge_span(v1->span, v2->span));
    }
    if (v1->kind == VALUE_BOOL && v2->kind == VALUE_BOOL) {
	return value_make_bool((as(bool, v1) == as(bool, v2)), merge_span(v1->span, v2->span));
    }
    return value_make_bool(false, merge_span(v1->span, v2->span));
}

std::string value_to_string(ValueRef v) {
    if (v->kind == VALUE_STRING) {
	auto string_value = std::get<std::string>(v->data);
    return string_value;
  }
  if (v->kind == VALUE_INT) {
    auto int_value = std::get<int>(v->data);
    return imp_arena_strdup(arena, std::format("{}", int_value).data());
  }
  if (v->kind == VALUE_VARIABLE) {
      auto value = std::get<ValueRef>(v->data);
    return value_to_string(value);
  }
  return "nil";
}
